var CLIENT_CMD = ["AUTH", "SEND", "ACK"];
var SERVER_CMD = ["ACKN", "SEND", "ARRV", "LEFT"];
var RESPONSE_CMD = ["OKAY", "FAIL", "INVD"];
var FAIL_MSG = {
    "NAME": "The specified name is already in use by another client",
    "PASSWORD": "The password is not acceptable for authentication on this server",
    "NUMBER": "A number is not valid, either because it has already been used for another entity in case it was newly generated by the client, or there is no relevant entity that the number refers to",
    "LENGTH": "The chat message text is too long"
}

function ChatProtocal(cmd, number, data) {
    var r = new Object();
    r.cmd = cmd;
    r.number = number;
    r.data = data;
    r.toString = function() {
        if (data != null) {
            return r.cmd + " " + r.number + "\r\n" + data;
        } else {
            return r.cmd + " " + r.number;
        }
    }
    return r;
}

function ChatUser(number, name, description) {
    var u = new Object();
    u.number = number;
    u.name = name;
    u.description = description;
    u.toString = function() {
        return u.name + "[" + u.number + "] - " + u.description;
    }
    return u;
}

var ChatClient = {
    ws: null,
    host: "modestchecker.net",
    port: 42015,
    number: 0,
    name: "",
    password: "",
    timer: null,

    users: {},
    onresponses: {},
    oncmds: {},

    connect: function() {
        var client = this;
        console.log("ws connecting")

        this.number = getRandomInt();
        this.users = {};
        this.onresponses = {};

        this.ws = new WebSocket("ws://" + this.host + ":" + this.port);

        // CMD ACKN
        this.oncmds["ACKN"] = function(r) {
            var u = client.users[Number.parseInt(r.data[0])];
            console.log("S: ACKN: " + u.toString());
            markMessageAcknowledged(r.number, u.name);
        }

        // CMD ARRV
        this.oncmds["ARRV"] = function(r) {
            var u = ChatUser(r.number, r.data[0], r.data[1]);
            client.users[u.number] = u; // save user

            addUser(u.number, u.name, u.description);
            addInfoMessage(u.name + " has entered.");
            console.log("S: ARRV: " + u.toString());
        }

        // CMD SEND
        this.oncmds["SEND"] = function(r) {
            console.log("S: SEND: " + r.toString());
            var u = client.users[Number.parseInt(r.data[0])]
            var msg = r.data[1];
            addChatMessage(r.number, u.name, msg, false);
            client.acknowledge(r.number);
        }

        // CMD LEFT
        this.oncmds["LEFT"] = function(r) {
            var u = client.users[r.number];
            if (u != null) {
                console.log("S: LEFT: " + u.toString());
                addInfoMessage(u.name + " has leave.");
                removeUser(r.number);
                delete client.users[r.number];
            } else {
                console.log("S: LEFT: unknow(" + r.number + ")");
            }
        }

        this.oncmds["FAIL"] = function(r) {
            if (r.data[0] != 'UNSUPPORTED') {           
                console.log("S: FAIL: " + r.data[0]);
                addInfoMessage("FAIL: " + FAIL_MSG[r.data[0]]);
            }
        }

        this.ws.onopen = function() {
            //console.log("ws connected");
            onConnected(this.host);
            client.timer = window.setInterval(function() {
                console.log("ping");
                var r = ChatProtocal("PING", client.number);
                client._send(r, function(r) {

                });
            }, 5000);
        }
        this.ws.onclose = function() {
            //console.log("ws closed");
            window.clearInterval(client.timer);
            onDisconnected();
            clearUsers();
        }
        this.ws.onmessage = function(e) {
            //console.log("ws onmessage: " + e.data);
            var r = client._recv(e.data);
            if (r != null) {
                handler = client.oncmds[r.cmd];
                if (handler != null) {
                    handler(r);
                } else {
                    console.log("SERVER_CMD: " + r.cmd);
                }
            }
        }
        this.ws.onerror = function(err) {
            console.log("ws onerror: " + err);
            onConnectionFailed();
        }
    },
    disconnect: function() {
        console.log("ws disconnecting");
        this.ws.close();
    },
    login: function(name, password) {
        var client = this;
        var r = ChatProtocal("AUTH", this.number, name + "\r\n" + password);
        this._send(r, function(r) {
            console.log("C: AUTH: " + r.toString());
            if (r.cmd == "OKAY") {
                client.name = name;
                client.password = password;
                onLoginSuccess();
            } else {
                onLoginFailed();
            }
        });
    },
    message: function(msg, to) {
        addChatMessage(this.number, this.name, msg, true);
        var r = ChatProtocal("SEND", this.number, to + "\r\n" + msg);
        this._send(r, function(r) {
            console.log("C: SEND: " + r.toString());
            if (r.cmd == "OKAY") {
                setStatusBarText("Message sent");
            } else {
                setStatusBarText("Send message failed");
            }
        })
    },
    acknowledge: function(number) {
        var r = ChatProtocal("ACKN", number);
        this._send(r, function(r) {
            console.log("C: ACKN: " + r.toString());
            if (r.cmd == "OKAY") {
            }
        })
    },
    _send: function(r, onresponse) {
        this.onresponses[r.number] = onresponse;
        console.log("send: " + r.toString());
        this.ws.send(r.toString());
        this.number = getRandomInt();
    },
    _recv: function(data) {
        data = data.split("\r\n");
        if (data.length >= 1) {
            cmd_number = data[0].split(" ");
            if (cmd_number.length == 2) {
                cmd = cmd_number[0];
                number = Number.parseInt(cmd_number[1]);
                if ((SERVER_CMD.indexOf(cmd) != -1 || RESPONSE_CMD.indexOf(cmd) != -1) && number != NaN) {
                    r = ChatProtocal(cmd, number, data.slice(1, data.length));
                    onresponse = this.onresponses[number];
                    if (onresponse != undefined) {
                        onresponse(r);
                        delete this.onresponses[number];
                    }
                    return r;
                } else {
                    console.log("cmd or number error");
                }
            } else {
                console.error("cmd and number format error");
            }
        } else {
            console.error("data format error");
        }
    },
};